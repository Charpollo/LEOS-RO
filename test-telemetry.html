<!DOCTYPE html>
<html>
<head>
    <title>Telemetry Test</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 20px;
        }
        .status {
            border: 1px solid #0f0;
            padding: 10px;
            margin: 10px 0;
            background: rgba(0, 255, 0, 0.1);
        }
        .error {
            color: #f00;
            border-color: #f00;
            background: rgba(255, 0, 0, 0.1);
        }
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px 20px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: rgba(0, 255, 0, 0.2);
        }
        pre {
            overflow: auto;
            max-height: 400px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <h1>RED ORBIT â†’ RED WATCH Telemetry Test</h1>
    
    <div class="status" id="connection">
        Connection Status: <span id="status">Not Connected</span>
    </div>
    
    <div>
        <button onclick="connectTelemetry()">Connect to RED WATCH</button>
        <button onclick="disconnectTelemetry()">Disconnect</button>
        <button onclick="testExport()">Test Export Data</button>
        <button onclick="sendTestData()">Send Test Batch</button>
    </div>
    
    <h2>Last Data Sent:</h2>
    <pre id="output"></pre>
    
    <h2>Statistics:</h2>
    <div id="stats"></div>

    <script type="module">
        // Make functions global for button onclick
        window.connectTelemetry = async function() {
            try {
                const module = await import('./frontend/js/telemetry/universal-telemetry-connector.js');
                
                if (!window.telemetryConnector) {
                    window.telemetryConnector = new module.UniversalTelemetryConnector({
                        endpoint: 'ws://localhost:8000/ws/ingest',
                        name: 'RED WATCH',
                        dataConfig: { 
                            format: 'redwatch',
                            sendAllObjects: true,
                            includeMetrics: true,
                            includeConjunctions: true,
                            includeAlerts: true
                        }
                    });
                }
                
                window.telemetryConnector.enable();
                document.getElementById('status').textContent = 'Connecting...';
                document.getElementById('status').style.color = '#ff0';
                
                // Check connection after a moment
                setTimeout(() => {
                    const status = window.telemetryConnector.getStatus();
                    if (status.connected) {
                        document.getElementById('status').textContent = 'Connected to RED WATCH';
                        document.getElementById('status').style.color = '#0f0';
                        updateStats();
                    } else {
                        document.getElementById('status').textContent = 'Failed to connect';
                        document.getElementById('status').style.color = '#f00';
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Failed to connect:', error);
                document.getElementById('status').textContent = 'Error: ' + error.message;
                document.getElementById('status').style.color = '#f00';
            }
        };
        
        window.disconnectTelemetry = function() {
            if (window.telemetryConnector) {
                window.telemetryConnector.disable();
                document.getElementById('status').textContent = 'Disconnected';
                document.getElementById('status').style.color = '#999';
            }
        };
        
        window.testExport = async function() {
            // Create mock GPU physics engine for testing
            if (!window.gpuPhysicsEngine) {
                window.gpuPhysicsEngine = {
                    activeObjects: 10000,
                    exportObjectData: async function(maxObjects) {
                        const objects = [];
                        const count = Math.min(this.activeObjects, maxObjects);
                        
                        for (let i = 0; i < count; i++) {
                            // Generate realistic orbital positions
                            const altitude = 400 + Math.random() * 1600; // 400-2000 km
                            const r = (6371 + altitude) * 1000; // meters from Earth center
                            const theta = Math.random() * 2 * Math.PI;
                            const phi = Math.random() * Math.PI;
                            
                            objects.push({
                                id: `SAT-${i}`,
                                name: `Satellite-${i}`,
                                type: Math.random() > 0.9 ? 'debris' : 'satellite',
                                position: {
                                    x: r * Math.sin(phi) * Math.cos(theta),
                                    y: r * Math.sin(phi) * Math.sin(theta),
                                    z: r * Math.cos(phi)
                                },
                                velocity: {
                                    x: 7500 * Math.random(),
                                    y: 7500 * Math.random(),
                                    z: 7500 * Math.random()
                                },
                                altitude: altitude,
                                mass: 1000 + Math.random() * 4000,
                                status: 'active',
                                last_updated: new Date().toISOString()
                            });
                        }
                        
                        return objects;
                    }
                };
                
                window.redOrbitPhysics = window.gpuPhysicsEngine;
            }
            
            try {
                const objects = await window.gpuPhysicsEngine.exportObjectData(100);
                document.getElementById('output').textContent = JSON.stringify(objects.slice(0, 5), null, 2);
                console.log(`Exported ${objects.length} objects`);
                
                // Show summary
                const summary = `
Exported ${objects.length} objects
Satellites: ${objects.filter(o => o.type === 'satellite').length}
Debris: ${objects.filter(o => o.type === 'debris').length}
Average altitude: ${Math.round(objects.reduce((sum, o) => sum + o.altitude, 0) / objects.length)} km
                `;
                document.getElementById('stats').textContent = summary;
                
            } catch (error) {
                console.error('Export failed:', error);
                document.getElementById('output').textContent = 'Error: ' + error.message;
            }
        };
        
        window.sendTestData = async function() {
            if (!window.telemetryConnector || !window.telemetryConnector.connected) {
                alert('Please connect first!');
                return;
            }
            
            // Ensure we have test data
            await testExport();
            
            // Force send telemetry
            await window.telemetryConnector.sendTelemetry();
            
            updateStats();
        };
        
        function updateStats() {
            if (window.telemetryConnector) {
                const status = window.telemetryConnector.getStatus();
                const stats = `
Messages sent: ${status.messagesSent}
Bytes sent: ${(status.bytesSent / 1024).toFixed(2)} KB
Connected: ${status.connected}
Update rate: ${1000 / status.updateRate} Hz
                `;
                document.getElementById('stats').textContent = stats;
            }
        }
        
        // Auto-update stats
        setInterval(updateStats, 1000);
    </script>
</body>
</html>